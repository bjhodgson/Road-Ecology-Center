# Write summary table to Excel
write.xlsx(summary_df, path2, rowNames = FALSE)
library(readxl)
# Write summary table to Excel
write_xlsx(summary_df, path2, rowNames = FALSE)
# Write summary table to Excel
write_xlsx(summary_df, path2)
install.packages(writexl)
install.packages("writexl")
library(writexl)
# Write summary table to Excel
write_xlsx(summary_df, path2)
# Write summary table to Excel
write.csv(summary_df, path2)
?write_xlsx
# Write summary table to Excel
write.csv(summary_df, path2, "test.xlsx")
?write_xlsx
# Write summary table to Excel
#write.csv(summary_df, "C:\\Users\\Leo Hecht\\Documents\\Road Ecology\\Hotspot Report\\edited_dataset.csv", row.names = FALSE) # Leo path
write.csv(summary_df, "H:\\hotspots\\bridges\\bridges_new\\output_data\\hotspots_summary.xlsx", row.names = FALSE) # Ben path
# Write summary table to Excel
#write.csv(summary_df, "C:\\Users\\Leo Hecht\\Documents\\Road Ecology\\Hotspot Report\\edited_dataset.csv", row.names = FALSE) # Leo path
write.xlsx(summary_df, "H:\\hotspots\\bridges\\bridges_new\\output_data\\hotspots_summary.xlsx", row.names = FALSE) # Ben path
# Write summary table to Excel
#write.csv(summary_df, "C:\\Users\\Leo Hecht\\Documents\\Road Ecology\\Hotspot Report\\edited_dataset.csv", row.names = FALSE) # Leo path
write.xlsx(summary_df, "H:\\hotspots\\bridges\\bridges_new\\output_data\\hotspots_summary.xlsx", rowNames = FALSE) # Ben path
# Save the edited dataset to csv
#write.csv(df, "C:\\Users\\Leo Hecht\\Documents\\Road Ecology\\Hotspot Report\\edited_dataset.csv", row.names = FALSE) # Leo path
write.csv(df_filtered, "H:\\hotspots\\bridges\\bridges_new\\output_data\\hotspots_summary.xlsx", row.names = FALSE) # Ben path
# Save the edited dataset to csv
#write.csv(df, "C:\\Users\\Leo Hecht\\Documents\\Road Ecology\\Hotspot Report\\edited_dataset.csv", row.names = FALSE) # Leo path
write.csv(df_filtered, "H:\\hotspots\\bridges\\bridges_new\\output_data\\hotspots.csv", row.names = FALSE) # Ben path
# Write summary table to Excel
#write.xlsx(summary_df, "C:\\Users\\Leo Hecht\\Documents\\Road Ecology\\Hotspot Report\\edited_dataset.csv", rowNames = FALSE) # Leo path
write.xlsx(summary_df, "H:\\hotspots\\bridges\\bridges_new\\output_data\\hotspots_summary.xlsx", rowNames = FALSE) # Ben path
# Write summary table to Excel
#write.csv(summary_df, "C:\\Users\\Leo Hecht\\Documents\\Road Ecology\\Hotspot Report\\hotspots_summary.csv", rowNames = FALSE) # Leo path
write.csv(summary_df, "H:\\hotspots\\bridges\\bridges_new\\output_data\\hotspots_summary.csv", rowNames = FALSE) # Ben path
# Write summary table to Excel
#write.csv(summary_df, "C:\\Users\\Leo Hecht\\Documents\\Road Ecology\\Hotspot Report\\hotspots_summary.csv", rowNames = FALSE) # Leo path
write.csv(summary_df, "H:\\hotspots\\bridges\\bridges_new\\output_data\\hotspots_summary.csv") # Ben path
# Write summary table to Excel
#write.csv(summary_df, "C:\\Users\\Leo Hecht\\Documents\\Road Ecology\\Hotspot Report\\hotspots_summary.csv", rowNames = FALSE) # Leo path
write.csv(summary_df, "H:\\hotspots\\bridges\\bridges_new\\output_data\\hotspots_summary.csv", row.names = FALSE) # Ben path
# Group by new_sequence and extract the first record
first_records <- df_filtered %>%
group_by(new_sequence) %>%
slice_min(ORIG_FID) %>%
ungroup()
# Print or view the first_records dataframe
print(first_records)
View(first_records)
# Group by new_sequence and select the first record
first_records <- df_filtered %>%
group_by(new_sequence) %>%
slice(1) %>%  # Select the first record in each group
ungroup()
View(first_records)
# Write map points to csv
write.csv(summary_df, "H:\\hotspots\\bridges\\bridges_new\\output_data\\map_hotspots.csv", row.names = FALSE) # Ben path
# Write map points to csv
write.csv(map_hotspots, "H:\\hotspots\\bridges\\bridges_new\\output_data\\map_hotspots.csv", row.names = FALSE) # Ben path
# Group by new_sequence and select the first record
map_hotspots <- df_filtered %>%
group_by(new_sequence) %>%
slice(1) %>%  # Select the first record in each group
ungroup()
# Write map points to csv
write.csv(map_hotspots, "H:\\hotspots\\bridges\\bridges_new\\output_data\\map_hotspots.csv", row.names = FALSE) # Ben path
View(map_hotspots)
# Write map points to csv
write.csv(map_hotspots, "H:\\hotspots\\bridges\\bridges_new\\output_data\\map_hotspots.csv", row.names = FALSE) # Ben path
# Load the dataset
#points_100ft <- read.csv("C:\\Users\\Leo Hecht\\Documents\\Road Ecology\\Hotspot Report\\output_data\\points_table_fence.csv")
points_100ft <- read.csv("D:\\hotspots\\fences\\output_data\\points_bridges_PM.csv")
# Create a new column called "fence" and initialize it to 0
points_100ft$fence <- 0
# Identify bridge points
bridge_indices <- which(points_100ft$VCU == 0)
# Loop through each pair of bridge indices
for (i in seq_along(bridge_indices)) {
# Define the current bridge index
bridge_idx <- bridge_indices[i]
# Skip if it's the last bridge (no bridge after it to form a pair)
if (i == length(bridge_indices)) {
next
}
# Define the next bridge index
next_bridge_idx <- bridge_indices[i + 1]
# Check if there is at least one point with annl_nc >= 2 between the bridges
if (any(points_100ft$annl_nc[(bridge_idx + 1):(next_bridge_idx - 1)] >= 2)) {
# Mark points between the current and next bridge
points_100ft$fence[bridge_idx:next_bridge_idx] <- 1
}
}
View(points_100ft)
# Create a new column called "fence" and initialize it to 0
points_100ft$fence <- 0
# Identify bridge points
bridge_indices <- which(points_100ft$VCU == 0)
# Loop through each pair of bridge indices
for (i in seq_along(bridge_indices)) {
# Define the current bridge index
bridge_idx <- bridge_indices[i]
# Skip if it's the last bridge (no bridge after it to form a pair)
if (i == length(bridge_indices)) {
next
}
# Define the next bridge index
next_bridge_idx <- bridge_indices[i + 1]
# Check if there is at least one point with annl_nc > 2 between the bridges
if (any(points_100ft$annl_nc[(bridge_idx + 1):(next_bridge_idx - 1)] > 2)) {
# Mark points between the current and next bridge
points_100ft$fence[bridge_idx:next_bridge_idx] <- 1
}
}
# Save the edited dataset
#write.csv(points_100ft, "C:\\Users\\Leo Hecht\\Documents\\Road Ecology\\Hotspot Report\\dataset_with_fence_processed.csv", row.names = FALSE)
write.csv(points_100ft, "D:\\hotspots\\fences\\output_data\\hotspot_fences.csv", row.names = FALSE)
# Load the dataset
#points_100ft <- read.csv("C:\\Users\\Leo Hecht\\Documents\\Road Ecology\\Hotspot Report\\output_data\\points_table_fence.csv") # Leo path
points_100ft <- read.csv("D:\\hotspots\\fences\\output_data\\wcc_bridges.csv") # Ben path
View(points_100ft)
# Create a new column called "fence" and initialize it to 0
points_100ft$fence <- 0
# Identify bridge points
bridge_indices <- which(points_100ft$VCU == 0)
# Loop through each pair of bridge indices
for (i in seq_along(bridge_indices)) {
# Define the current bridge index
bridge_idx <- bridge_indices[i]
# Skip if it's the last bridge (no bridge after it to form a pair)
if (i == length(bridge_indices)) {
next
}
# Define the next bridge index
next_bridge_idx <- bridge_indices[i + 1]
# Check if there is at least one point with annl_nc > 2 between the bridges
if (any(points_100ft$annl_nc[(bridge_idx + 1):(next_bridge_idx - 1)] > 2)) {
# Mark points between the current and next bridge
points_100ft$fence[bridge_idx:next_bridge_idx] <- 1
}
}
View(points_100ft)
points_100ft$fence
sum(points_100ft$fence)
# Save the edited dataset
#write.csv(points_100ft, "C:\\Users\\Leo Hecht\\Documents\\Road Ecology\\Hotspot Report\\dataset_with_fence_processed.csv", row.names = FALSE) # Leo path
write.csv(points_100ft, "D:\\hotspots\\fences\\output_data\\hotspot_fences.csv", row.names = FALSE) # Ben path
View(points_100ft)
fences_df <- points_100ft %>%
filter(fence == 1)
library(dplyr)
fences_df <- points_100ft %>%
filter(fence == 1)
View(fences_df)
write.csv(fences_df, "D:\\hotspots\\fences\\output_data\\fences_df.csv", row.names = FALSE) # Ben path
sum(points_100ft$VCU == 0)
sum(points_100ft$VCU == 0)
any(points_100ft$VCU == 0)
sum(points_100ft$VCU)
library(readxl)
library(dplyr)
# Read the CSV file
points_100ft <- read.csv("D:\\hotspots\\fences\\output_data\\wcc_bridges.csv")
# Initialize a variable to store the count of records above the found annl_nc > 2
count_records_above <- 0
# Initialize a flag to indicate if the record has been found
record_found <- FALSE
# Loop through the dataframe to find the first annl_nc > 2
for (i in 1:nrow(points_100ft)) {
if (points_100ft$annl_nc[i] > 2) {
# Start counting records above this point
for (j in seq(i-1, 1)) {
count_records_above <- count_records_above + 1
if (points_100ft$VCU[j] == 0) {
# Stop counting once a VCU == 0 record is found
record_found <- TRUE
break
}
}
# Break the outer loop if the record is found
if (record_found) {
break
}
}
}
points_100ft
library(readxl)
library(dplyr)
# Read the CSV file
fences_df <- read.csv("D:\\hotspots\\fences\\output_data\\wcc_bridges.csv")
# Initialize a variable to store the count of records above the found annl_nc > 2
count_records_above <- 0
# Initialize a flag to indicate if the record has been found
record_found <- FALSE
# Loop through the dataframe to find the first annl_nc > 2
for (i in 1:nrow(fences_df)) {
if (fences_df$annl_nc[i] > 2) {
# Start counting records above this point
for (j in seq(i-1, 1)) {
count_records_above <- count_records_above + 1
if (fences_df$VCU[j] == 0) {
# Stop counting once a VCU == 0 record is found
record_found <- TRUE
break
}
}
# Break the outer loop if the record is found
if (record_found) {
break
}
}
}
# Loop through the dataframe to find the first annl_nc > 2
for (i in 1:nrow(points_100ft)) {
if (!is.na(points_100ft$annl_nc[i]) && points_100ft$annl_nc[i] > 2) {
# Start counting records above this point
for (j in seq(i-1, 1, -1)) {
count_records_above <- count_records_above + 1
if (!is.na(points_100ft$VCU[j]) && points_100ft$VCU[j] == 0) {
# Stop counting once a VCU == 0 record is found
record_found <- TRUE
break
}
}
# Break the outer loop if the record is found
if (record_found) {
break
}
}
}
# Output the count of records above the found annl_nc > 2
print(count_records_above)
# Initialize a variable to store the count of records above the found annl_nc > 2
count_records_above <- 0
# Initialize a variable to store the count of records below the found annl_nc > 2 until VCU == 0
count_records_below <- 0
# Initialize a flag to indicate if the first record with annl_nc > 2 is found
record_found_above <- FALSE
# Initialize a flag to indicate if a record with VCU == 0 is found after annl_nc > 2
record_found_below <- FALSE
# Loop through the dataframe to find the first annl_nc > 2 and count records above and below
for (i in 1:nrow(fences_df)) {
# Check for annl_nc > 2
if (!is.na(fences_df$annl_nc[i]) && fences_df$annl_nc[i] > 2) {
# Start counting records above this point
for (j in seq(i-1, 1, -1)) {
count_records_above <- count_records_above + 1
if (!is.na(fences_df$VCU[j]) && fences_df$VCU[j] == 0) {
# Stop counting once a VCU == 0 record is found
record_found_above <- TRUE
break
}
}
# Continue searching downwards from annl_nc > 2
for (k in seq(i+1, nrow(fences_df))) {
if (!is.na(fences_df$VCU[k]) && fences_df$VCU[k] == 0) {
# Found a record with VCU == 0 below annl_nc > 2
record_found_below <- TRUE
break
}
count_records_below <- count_records_below + 1
}
# Break the outer loop if both records are found
if (record_found_above && record_found_below) {
break
}
}
}
# Output the counts of records above and below the found annl_nc > 2
print(paste("Records above annl_nc > 2:", count_records_above))
print(paste("Records below annl_nc > 2 until VCU == 0:", count_records_below))
# Initialize a variable to store the objectID of the record found
objectID_annl_nc_above_2 <- NA
# Loop through the dataframe to find the first record where annl_nc > 2
for (i in 1:nrow(fences_df)) {
if (!is.na(fences_df$annl_nc[i]) && fences_df$annl_nc[i] > 2) {
# Found the first record where annl_nc > 2
objectID_annl_nc_above_2 <- fences_df$objectID[i]
break  # Exit the loop once found
}
}
# Output the objectID of the record where annl_nc > 2
print(paste("ObjectID of record where annl_nc > 2:", objectID_annl_nc_above_2))
colnames(fences_df)
# Initialize a variable to store the objectID of the record found
OBJECTID_annl_nc_above_2 <- NA
# Loop through the dataframe to find the first record where annl_nc > 2
for (i in 1:nrow(fences_df)) {
if (!is.na(fences_df$annl_nc[i]) && fences_df$annl_nc[i] > 2) {
# Found the first record where annl_nc > 2
OBJECTID_annl_nc_above_2 <- fences_df$OBJECTID[i]
break  # Exit the loop once found
}
}
# Output the objectID of the record where annl_nc > 2
print(paste("ObjectID of record where annl_nc > 2:", OBJECTID_annl_nc_above_2))
# Output the counts of records above and below the found annl_nc > 2
print(paste("Records above annl_nc > 2:", count_records_above))
print(paste("Records below annl_nc > 2 until VCU == 0:", count_records_below))
# Initialize an empty vector to store OBJECTIDs
OBJECTIDs_vcu_zero <- c()
# Loop through the dataframe to find records where VCU == 0
for (i in 1:nrow(fences_df)) {
if (!is.na(fences_df$VCU[i]) && fences_df$VCU[i] == 0) {
# Found a record where VCU == 0
OBJECTIDs_vcu_zero <- c(OBJECTIDs_vcu_zero, fences_df$OBJECTID[i])
}
}
# Output the OBJECTIDs where VCU == 0
print(paste("OBJECTIDs where VCU == 0:", toString(OBJECTIDs_vcu_zero)))
length(OBJECTIDs_vcu_zero)
# Initialize variables to store OBJECTIDs
objectID_vcu_zero <- vector("numeric", 2)  # Assuming OBJECTID is numeric, change accordingly if different
# Initialize a counter for the number of VCU == 0 records found
count_vcu_zero <- 0
# Loop through the dataframe to find the first record where annl_nc > 2 and record OBJECTID
for (i in 1:nrow(fences_df)) {
if (!is.na(fences_df$annl_nc[i]) && fences_df$annl_nc[i] > 2) {
# Start counting records above this point
for (j in seq(i-1, 1, -1)) {
if (!is.na(fences_df$VCU[j]) && fences_df$VCU[j] == 0) {
# Found a record with VCU == 0 above annl_nc > 2
count_vcu_zero <- count_vcu_zero + 1
if (count_vcu_zero <= 2) {
objectID_vcu_zero[count_vcu_zero] <- fences_df$OBJECTID[j]
}
if (count_vcu_zero == 2) {
break
}
}
}
# Break the outer loop if both OBJECTIDs are found
if (count_vcu_zero == 2) {
break
}
}
}
# Output the OBJECTIDs of the first two records where VCU == 0
print(paste("OBJECTIDs of the first two records where VCU == 0:", toString(objectID_vcu_zero)))
print(paste("Records above annl_nc > 2:", count_records_above))
print(paste("Records below annl_nc > 2 until VCU == 0:", count_records_below))
# Initialize a variable to store the count of records above the found annl_nc > 2
count_records_above <- 0
# Initialize a variable to store the count of records below the found annl_nc > 2 until VCU == 0
count_records_below <- 0
# Initialize a flag to indicate if the first record with annl_nc > 2 is found
record_found_above <- FALSE
# Initialize a flag to indicate if a record with VCU == 0 is found after annl_nc > 2
record_found_below <- FALSE
# Loop through the dataframe to find the first annl_nc > 2 and count records above and below
for (i in 1:nrow(fences_df)) {
# Check for annl_nc > 2
if (!is.na(fences_df$annl_nc[i]) && fences_df$annl_nc[i] > 2) {
# Start counting records above this point
for (j in seq(i-1, 1, -1)) {
count_records_above <- count_records_above + 1
if (!is.na(fences_df$VCU[j]) && fences_df$VCU[j] == 0) {
# Stop counting once a VCU == 0 record is found
record_found_above <- TRUE
break
}
}
# Continue searching downwards from annl_nc > 2
for (k in seq(i+1, nrow(fences_df))) {
if (!is.na(fences_df$VCU[k]) && fences_df$VCU[k] == 0) {
# Found a record with VCU == 0 below annl_nc > 2
record_found_below <- TRUE
break
}
count_records_below <- count_records_below + 1
}
# Break the outer loop if both records are found
if (record_found_above && record_found_below) {
break
}
}
}
# Output the counts of records above and below the found annl_nc > 2
print(paste("Records above annl_nc > 2:", count_records_above))
print(paste("Records below annl_nc > 2 until VCU == 0:", count_records_below))
# Initialize variables to store OBJECTIDs
objectID_above <- NA
objectID_below <- NA
objectID_second_below <- NA
# Initialize variables to store counts
count_records_between <- 0
# Initialize a flag to indicate if the first record with annl_nc > 2 is found
record_found_above <- FALSE
# Initialize a flag to indicate if a record with VCU == 0 is found after annl_nc > 2
record_found_below <- FALSE
# Loop through the dataframe to find the first annl_nc > 2 and record OBJECTID
for (i in 1:nrow(fences_df)) {
if (!is.na(fences_df$annl_nc[i]) && fences_df$annl_nc[i] > 2) {
# Start counting records above this point
for (j in seq(i-1, 1, -1)) {
if (!is.na(fences_df$VCU[j]) && fences_df$VCU[j] == 0) {
# Found a record with VCU == 0 above annl_nc > 2
objectID_above <- fences_df$OBJECTID[j]
record_found_above <- TRUE
break
}
}
# Continue searching downwards from annl_nc > 2
for (k in seq(i+1, nrow(fences_df))) {
if (!is.na(fences_df$VCU[k]) && fences_df$VCU[k] == 0) {
# Found a record with VCU == 0 below annl_nc > 2
objectID_below <- fences_df$OBJECTID[k]
record_found_below <- TRUE
break
}
count_records_between <- count_records_between + 1
}
# Break the loop if both OBJECTIDs are found
if (record_found_above && record_found_below) {
break
}
}
}
# Output the OBJECTIDs of the records where annl_nc > 2 and VCU == 0
print(paste("OBJECTID where annl_nc > 2 and VCU == 0 (first record):", objectID_above))
print(paste("OBJECTID where annl_nc > 2 and VCU == 0 (second record):", objectID_below))
10327-9593
# Initialize a variable to store the count of records above the found annl_nc > 2
count_records_above <- 0
# Initialize a variable to store the count of records below the found annl_nc > 2 until VCU == 0
count_records_below <- 0
# Initialize a flag to indicate if the first record with annl_nc > 2 is found
record_found_above <- FALSE
# Initialize a flag to indicate if a record with VCU == 0 is found after annl_nc > 2
record_found_below <- FALSE
# Loop through the dataframe to find the first annl_nc > 2 and count records above and below
for (i in 1:nrow(fences_df)) {
# Check for annl_nc > 2
if (!is.na(fences_df$annl_nc[i]) && fences_df$annl_nc[i] > 2) {
# Start counting records above this point
for (j in seq(i-1, 1, -1)) {
count_records_above <- count_records_above + 1
if (!is.na(fences_df$VCU[j]) && fences_df$VCU[j] == 0) {
# Stop counting once a VCU == 0 record is found
record_found_above <- TRUE
break
}
}
# Continue searching downwards from annl_nc > 2
for (k in seq(i+1, nrow(fences_df))) {
if (!is.na(fences_df$VCU[k]) && fences_df$VCU[k] == 0) {
# Found a record with VCU == 0 below annl_nc > 2
record_found_below <- TRUE
break
}
count_records_below <- count_records_below + 1
}
# Break the outer loop if both records are found
if (record_found_above && record_found_below) {
break
}
}
}
# Output the counts of records above and below the found annl_nc > 2
print(paste("Records above annl_nc > 2:", count_records_above))
print(paste("Records below annl_nc > 2 until VCU == 0:", count_records_below))
# Output the OBJECTIDs of the records where annl_nc > 2 and VCU == 0
print(paste("OBJECTID where annl_nc > 2 and VCU == 0 (first record):", objectID_above))
print(paste("OBJECTID where annl_nc > 2 and VCU == 0 (second record):", objectID_below))
# Initialize a variable to store the count of records above the found annl_nc > 2
count_records_above <- 0
# Initialize a variable to store the count of records below the found annl_nc > 2 until VCU == 0
count_records_below <- 0
# Initialize a flag to indicate if the first record with annl_nc > 2 is found
record_found_above <- FALSE
# Initialize a flag to indicate if a record with VCU == 0 is found after annl_nc > 2
record_found_below <- FALSE
# Initialize variables to store RTE attribute for comparison
target_RTE <- NA
current_RTE <- NA
# Loop through the dataframe to find the first annl_nc > 2 and count records above and below
for (i in 1:nrow(fences_df)) {
# Check for annl_nc > 2
if (!is.na(fences_df$annl_nc[i]) && fences_df$annl_nc[i] > 2) {
target_RTE <- fences_df$RTE[i]  # Get RTE attribute for comparison
# Start counting records above this point
for (j in seq(i-1, 1, -1)) {
if (fences_df$RTE[j] == target_RTE) {  # Check RTE attribute match
count_records_above <- count_records_above + 1
if (!is.na(fences_df$VCU[j]) && fences_df$VCU[j] == 0) {
# Stop counting once a VCU == 0 record is found
record_found_above <- TRUE
break
}
}
}
# Continue searching downwards from annl_nc > 2
for (k in seq(i+1, nrow(fences_df))) {
current_RTE <- fences_df$RTE[k]  # Get RTE attribute for comparison
if (current_RTE == target_RTE) {  # Check RTE attribute match
if (!is.na(fences_df$VCU[k]) && fences_df$VCU[k] == 0) {
# Found a record with VCU == 0 below annl_nc > 2 and same RTE attribute
record_found_below <- TRUE
break
}
count_records_below <- count_records_below + 1
}
}
# Break the outer loop if both records are found
if (record_found_above && record_found_below) {
break
}
}
}
